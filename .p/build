#!/usr/bin/env perl
# vim: set foldmethod=marker foldmarker={{{,}}} :
# preamble {{{
use v5.16; use warnings; use utf8;
use open qw[ :encoding(UTF-8) :std ];

my $debug_release = grep /^-$/, @ARGV;
# if debug_release, skip the Atom feed generation, because it's the slowest part, because of the movetime detection operation.

sub openfile { my ($mode, $fpath) = @_;
  state $modes = {qw[
    r reading  w writing   a appending
    < reading  > writing  >> appending
    r+ read-writing  w+ write-reading   a+ read-appending
    +< read-writing  +> write-reading  +>> read-appending
  ]};
  my @caller = caller; my $trace = "at $caller[1] line $caller[2]";
  my $mode_desc = $modes->{$mode =~ s/b//gr};  # binary (b) is irrelevant and ignored on POSIX systems
  defined $mode_desc or die "bad open mode '$mode' for «$fpath», $trace\n";
  open my $fh, $mode, $fpath or die "Couldn’t open «$fpath» for $mode_desc: $!, $trace\n";
  return $fh;
}

sub slurp(_) { local $/; my $f = openfile '<', $_[0]; return scalar <$f> }

use FindBin;
# allow loading our libraries from the script's directory
use lib $FindBin::RealBin;
# change to the repo's root, regardless where we're called from.
chdir "$FindBin::RealBin/../";

# for hashing static files to cache-bust them on change
use Digest::file qw[ digest_file_base64 ];
sub hash(_) { digest_file_base64(shift, 'SHA-1') =~ tr[+/][-_]r }

# load our libraries

use Terms qw[
  get_terms
  get_links
];

my %terms = get_terms;
my %links = get_links;

use Parser qw[
  filepath_to_html
];

use GenAtom qw[
  gen_atom
];

# }}}

use constant HEADER => slurp '.t/head.html';

sub make_header { my ($additional_title, $path, $base) = @_;
  $path //= '';
  my $root = $base ? $base :
             $additional_title ? '../' : '';
  my $desc = $additional_title ? ' — '.$additional_title : ' للمصطلحات التقنية الحديثة';
  my $base_url = "https://www.noureddin.dev/ysmu";
  my $url  = "$base_url/$path/" =~ s,/+$,/,r;
  my $page = $path ? "$root$path/" : '';
  my $title = "معجم يسمو$desc";
  my $header_title = "معجم يسمو\n{{logo}}\n$desc" =~ s/ — //r
    =~ s|\Q{{logo}}\E|<span class="logo"><span>\N{SUNRISE OVER MOUNTAINS}</span></span>|r;
    # this hack (with the associated css) is to use the img on css-enabled browsers,
    # but to use the unicode character in reader mode and browsers w/o css.

  my $description = "معجم مجتمعي نتخير فيه أفضل مصطلح عربي فصيح سليم يجمع بين المعنى التقني والاستعمال الأصلي للكلمة العربية أو صحة اشتقاقها، ونشرح فيه أسباب اختيار هذا المصطلح والإعراض عن غيره.";  # the same the one in my home page

  return HEADER
    =~ s,\s+\z,,r
    =~ s,\Q{{title}}\E,$title,gr
    =~ s,\Q{{header_title}}\E,$header_title,gr
    =~ s,\Q{{url}}\E,$url,gr
    =~ s,\Q{{base_url}}\E,$base_url/,gr
    =~ s,\Q{{root}}\E,$root,gr
    =~ s,\Q{{description}}\E,$description,gr
    =~ s,\Q{{stylehash}}\E,hash('etc/style.min.css'),gre
    =~ s,\Qhref="$page"\E,aria-current="page",gr
    =~ s,\n\Z,,r  # to use say with almost everything
    # ensure proper text direction for the page's title (TODO: only for <title> and not meta og:title?)
    =~ s,(?<=<title>),\N{RIGHT-TO-LEFT EMBEDDING},r
    =~ s,(?=</title>),\N{POP DIRECTIONAL FORMATTING},r
}

my $feedicon = slurp 'etc/feed-icon.svg';
# based on https://en.wikipedia.org/wiki/File:Feed-icon.svg
# flipped & made monochrome with Inkscape,
# then compressed with vecta.io/nano
# then modified manually a bit.

use constant FOOTER => slurp('.t/foot.html') =~ s/\n\z//r;

use constant SCRIPT => slurp '.t/script.js';

use constant EMPTY_SCRIPT => <<'END_OF_TEXT';
<script>
  // redirect on nonpermalinks (eg, /#term) that aren't in this page
  const tl = {
    /***term*links***/
  }
  function goto_link () {
    const lnk = tl[location.hash]  // a term starts with '#'; tl only has terms that aren't in this page
    if (lnk) { location.href = lnk }  // redirect to the correct page and part of page
  }
  onload = goto_link
  onhashchange = goto_link
</script>
END_OF_TEXT

use constant SINGLE_STAGE_SCRIPT => SCRIPT
  =~ s{^}{  }mgr
  =~ s{^}{<script>\n}r
  =~ s{$}{\n</script>}r
  =~ s{\Q/***before*loop***/\E\n}{var nonempty = false\n}r
  =~ s{\Q/***end*of*loop***/\E\n}{if (a.className === '') { nonempty = true }\n}r
  =~ s{\n( *)\Q/***after*loop***/\E\n}{
$1document.querySelector('.emptytoc').style.display = nonempty ? 'none' : 'block'
$1var hv = nonempty ? 'block' : 'none'
$1document.querySelectorAll('.toc h3').forEach(function (e) { e.style.display = hv })
}r;

use constant MULTIPLE_STAGE_SCRIPT => SCRIPT
  =~ s{^}{  }mgr
  =~ s{^}{<script>\n}r
  =~ s{$}{\n</script>}r
  =~ s{\n *\Q/***before*loop***/\E\n}{\n}r
  =~ s{\n *\Q/***end*of*loop***/\E\n}{\n}r
  =~ s{\n( *)\Q/***after*loop***/\E\n}{
$1var tocs = document.querySelectorAll('.toc')
$1for (var i = 0; i < tocs.length; ++i) {
$1  var empty = tocs[i].querySelector('a:not(.hidden)') == null
$1  tocs[i].querySelector('.emptytoc').style.display = empty ? 'block' : 'none'
$1  var hv = empty ? 'none' : 'block'
$1  tocs[i].querySelectorAll('h3').forEach(function (e) { e.style.display = hv })
$1}
}r;

# where to redirect if the used a hash-url with a term that doesn't exist in the current page?
sub nonpermalinks_redirect { my ($cat, $ind) = @_;
  $ind //= "";
  # sort here is irrelevant; it's just to reduce unnecessary diffs between each build.
  # the '?' in the url is just a hint to the browser to re-request the html file
  #   not to used the cached (normally visited) page, to avoid potential infinite redirects
  #   between two old & new pages when a term is moved between them.
  my $root  = $cat eq 'w' ? "" : '../';
  return
    join '',
    map { my $t = $_; map { "$ind'#".lc."': '$root$terms{$t}{stage}?#$t',\n" } @{$terms{$t}{terms}} }
    # Note: {terms} (with lc) not {allterms}; lowering the case is handled is JS for this.
    sort
    grep { $terms{$_}{cat} ne $cat }
      keys %terms;
}

sub all_link    { '<a rel=index href="'.($_[0] // '').'link/">قائمة روابط جميع المصطلحات</a>' }
sub notes_link  { '<a rel=help href="'.($_[0] // '').'notes/">موارد وإرشادات</a>' }
sub rc_link     { '<a href="'.($_[0] // '').'candidate/">المصطلحات المرشحة للاتفاق</a>' }
sub exper_link  { '<a href="'.($_[0] // '').'experimental/">المصطلحات التجريبية</a>' }
sub tsv_link    { '<a rel=alternate type=text/tab-separated-values href="https://github.com/noureddin/ysmu/raw/main/ysmu.tsv">ysmu.tsv</a>' }
sub stable_link { '<a href="..">المصطلحات المتفق&nbsp;عليها</a>' }

sub make_footer { my ($s) = @_;
  my $foot = FOOTER;
  if ($s !~ /stable/) { $foot =~ s|\n.* TSV .*\n|\n|g }
  my $cat = $s =~ /stable/ ? 'w'
          : $s =~ /candidate/ ? 'c'
          : $s =~ /experimental/ ? 'x'
          : $s =~ /unstaged/ ? 'u'
            : "";
  return
  ( $s eq 'stable' ? $foot
      =~ s|<!--before-contact-->|<p>يمكنك أيضا رؤية @{[ rc_link ]}</p>|r
      =~ s,\Q{{root}}\E,,r
      =~ s,(?=</body>),@{[ SINGLE_STAGE_SCRIPT ]},r

  : $s eq 'empty stable' ? $foot
      =~ s|<!--before-contact-->|<p>يمكنك رؤية @{[ rc_link ]}</p>|r
      =~ s,\Q{{root}}\E,,r
      =~ s,(?=</body>),@{[ EMPTY_SCRIPT ]},r

  : $s eq 'candidate' ? $foot
      =~ s|<!--before-contact-->|<p>يمكنك أيضا رؤية @{[ exper_link '../' ]}</p>|r
      =~ s,(?=</body>),@{[ SINGLE_STAGE_SCRIPT ]},r

  : $s eq 'empty candidate' ? $foot
      =~ s|<!--before-contact-->|<p>يمكنك رؤية @{[ exper_link '../' ]}</p>|r
      =~ s,(?=</body>),@{[ EMPTY_SCRIPT ]},r

  : $s eq 'experimental' ? $foot
      =~ s|<!--after-contact-->|<p class="blurred">انظر أيضا: @{[ notes_link '../' ]}</p>|r
      =~ s,(?=</body>),@{[ SINGLE_STAGE_SCRIPT ]},r

  : $s eq 'empty experimental' ? $foot
      =~ s|<!--before-license-->|<p class="blurred">انظر أيضا: @{[ notes_link '../' ]}</p>|r
      =~ s,(?=</body>),@{[ EMPTY_SCRIPT ]},r

  : $s eq 'unstaged' ? $foot
      =~ s,(?=</body>),@{[ SINGLE_STAGE_SCRIPT ]},r

  : $s eq 'empty unstaged' ? $foot
      =~ s,(?=</body>),@{[ EMPTY_SCRIPT ]},r

  : $s eq 'all' ? $foot
      =~ s,(?=</body>),@{[ MULTIPLE_STAGE_SCRIPT ]},r

  : $s eq 'link' ? $foot
      =~ s,\Q{{root}}\E,../../,r

  : $s eq 'notes' ? $foot
      # =~ s|<!--before-contact-->|<p>يمكنك رؤية @{[ stable_link ]} أو @{[ exper_link '../' ]}</p>|r
      =~ s|<!--before-contact-->|<p>يمكنك رؤية @{[ all_link '../' ]}</p>|r

  : die "\e[1;31m  make_footer received wrong argument: '$s'\e[m\n"
  )
    =~ s,\Q{{root}}\E,../,r
    =~ s/\Q{{feedicon}}\E/$feedicon/r
    =~ s{\n( *)\Q/***term*links***/\E\n}{ "\n".nonpermalinks_redirect($cat, $1) }re
    =~ s| *<!--.*--> *\n||gr
}

# dynamic definitions {{{1

sub toc_links {  # takes array of [ $id, "#$id" ]; returns a string '<section class="toc">...</section>' or undef
  if (@_) {
    my %ltrs;
    return qq[<section class="toc">\n] . (
      join '',
        map {
          /href="[^#]*#(.)/;
          my $c = $1;
          $c = $c =~ /[0-9a-d]/ ? '0–9 A B C'
             : $c =~ /[d-n]/
               ? 'D E F G H I J K L M N'
               : 'O P Q R S T U V W X Y Z';
          ++$ltrs{$c};
          if (@_ > 17 && $ltrs{$c} == 1) { $_ = "<h3>$c</h3>\n$_" }
          $_
        }
        map {
          my $sum = "\N{RIGHT-TO-LEFT EMBEDDING}$terms{$_->[0]}{summary}\N{POP DIRECTIONAL FORMATTING}";
            # =~ s/  +/ /gr;  # multi-translation summaries have double-spaces
          my $spell = join ' ', map s/ /_/gr, @{$terms{$_->[0]}{spellings}};
          qq[  <a href="$_->[1]" title="$sum" data-spell="$spell">$terms{$_->[0]}{title}</a>\n]
        }
        sort { fc $a->[0] cmp fc $b->[0] }
          @_
    ) . qq[  <p class="emptytoc blurred" style="display:none">ما من مصطلحات توافق تصفيتك</p>\n</section>];
  }
  return;  # undef if empty
}

use constant TOC_FILTER => <<'END_OF_TEXT' =~ s/\Q{{L}}\E/اكتب لتصفية روابط المصطلحات/gr;
<form action="/ysmu/{{stage}}" method="GET">
<input id="toc_filter" name="q" type="search" dir="ltr" lang="en" placeholder="{{L}}" aria-label="{{L}}">
<button id="sub" type="submit" style="visibility:hidden;font-size:1pt;position:absolute;top:0">Search</button>
</form>
END_OF_TEXT

sub make_entries { my ($parent, $out_html, $out_tsv) = @_;
  my $n = 0;
  my @toc;
  my $body = "";
  my $tsv = "";
  for my $file (<$parent/*>) {
    ++$n;
    my ($t) = $file =~ m#/([^,]+)(?=,|$)#g;
    push @toc, [ $t, '#'.$t ];
    $body .= $terms{$t}{entry}."\n";
    if ($out_tsv) {
      my $has_explanation = $terms{$t}{entry} =~ m|<hr class="rm">\n<p>|;
      #
      my ($related_terms_html) =
        $terms{$t}{entry} =~ m|<p class="seealso">انظر أيضا:</p><ul>([^\0]*?)</ul>|;
      my @related_terms = map { $links{$_} } ($related_terms_html // '') =~ m|#([^"]+)"|g;
      #
      $tsv .= join "\t",
        $terms{$t}{title},
        $terms{$t}{summary} =~ s|\N{LEFT DOUBLE PARENTHESIS}(.*?)\N{RIGHT DOUBLE PARENTHESIS}|{{$1}}|gr,
        (join " ", ($has_explanation ? '@' : ()), @related_terms),
        (join " ", @{$terms{$t}{terms}}),
        (join " ", map s/ /_/gr, @{$terms{$t}{spellings}}),
        "\n";  # the preceding \t is removed after the loop
    }
  }
  $tsv =~ s/\t\n/\n/g;
  my $toc = toc_links(@toc) // "";
  my $root  = $parent eq 'w' ? "" : '../';
  my $stage = $parent eq 'w' ? ""
            : $parent eq 'c' ? 'candidate/'
            : $parent eq 'x' ? 'experimental/'
            : $parent eq 'u' ? 'unstaged/'
            : die "\e[1;31m  bad stage for '$parent' in make_entries/\e[m\n";
  my @links = ($body =~ /<a\b[^>]* href="#([^"]*)"/g);
  for my $lnk (@links) {
    if (!exists $links{$lnk}) {
      warn "Non-existent term: $lnk\n";
      $body =~ s,<a\b[^>]* href="#$lnk">(.*?)</a>,$1,g
    }
    else {
      my $t = $links{$lnk};
      if ($terms{$t}{stage} ne $stage) {  # not in this stage
        $body =~ s,(<a\b[^>]* href=")#$lnk",$1$root$terms{$t}{stage}#$t",g
      }
      elsif ($t ne $lnk) {  # normalize the term
        $body =~ s,(<a\b[^>]* href=")#$lnk",$1#$t",g
      }
    }
  }
  print { $out_html }
    ($toc ? (TOC_FILTER =~ s/\Q{{stage}}\E/$stage/gr).$toc."\n" : ""),
    "<main>\n".$body."</main>\n";
  print { $out_tsv } $tsv if $out_tsv;
  return $n;
}

# page & TSV generation {{{1

# we generate these files:
#   index.html, which contains the agreed-upon entries (in w/*).
#   ysmu.tsv, which summarizes the agreed-upon entries (in w/*).
#   candidate/index.html, which contains the "release candidate" entries (in c/*).
#   experimental/index.html, which contains the experimental entries (in x/*).
#   unstaged/index.html, which contains the unstaged entries (in u/*).
#   feed.atom.xml, which contains an Atom feed of all the terms with their summary definitions.
#   notes/index.html from notes/src, which is general prose.
#   link/index.html, which is an index of all terms in the four stages.
#   link/TERM/index.html, that redirects to '#TERM' in the right page.

# we start with the stable entries

my $index = openfile '>', 'index.html';
my $summary = openfile '>', 'ysmu.tsv';

say { $index } make_header;

if (make_entries('w', $index, $summary)) {  # if non-empty
  say { $index } make_footer 'stable';
}
else {  # if empty
  say { $index } '<article class="emptypage">لا توجد مصطلحات متفق عليها بعد</article>';
  say { $index } make_footer 'empty stable';
}

close $index;
close $summary;

# all other stages have an identical structure

use constant LAMMA =>
  qq[<a href="https://www.m-a-arabia.com/vb/showpost.php?s=b5f485336008816282cd7dfc5411d5ef&p=64761&postcount=3">ل\N{ZERO WIDTH JOINER}مّا</a>];

sub make_stage { my ($words_dir, $name, $title, $alert, $emptymsg) = @_;
  $alert = $alert =~ s|~|&nbsp;|gr =~ s/(\bو|\b)لمّا\b/$1@{[ LAMMA ]}/r;
  mkdir $name unless -d $name;
  my $fh = openfile '>', $name.'/index.html';
  #
  say { $fh } make_header $title, $name;
  #
  print { $fh } <<~"END_OF_TEXT" if $alert;
  <aside class="alert">
    <strong>تنبيه:</strong>
    $alert؛
    انظر @{[ stable_link ]}
  </aside>
  END_OF_TEXT
  #
  if (make_entries($words_dir, $fh, undef)) {  # if non-empty
    say { $fh } make_footer $name;
  }
  else {  # if empty
    say { $fh } qq[<main><article class="emptypage">$emptymsg</article></main>];
    say { $fh } make_footer "empty $name";
  }
  #
  close $fh;
}

sub make_page { my ($name, $header, $content, $footername) = @_;
  $footername //= $name =~ s,/.*,,r;
  mkdir $name unless -d $name;
  my $fh = openfile '>', $name.'/index.html';
  say { $fh } $header;
  say { $fh } $content;
  say { $fh } make_footer $footername;
  close $fh;
}

#################################################

make_stage 'c', 'candidate', 'المصطلحات المرشحة للاتفاق',
  'هذه المصطلحات مرشحة للاتفاق لكن لمّا يُتفقْ~عليها',
  'لا توجد مصطلحات مرشحة حاليا';

make_stage 'x', 'experimental', 'المصطلحات التجريبية',
  'هذه المصطلحات تجريبية ولمّا يُجمِع عليها المجتمع',
  'لا توجد مصطلحات تجريبية حاليا';

make_stage 'u', 'unstaged', 'المصطلحات المؤجلة',
  'هذه المصطلحات مؤجلة ولمّا تُناقش في المجتمع',
  'لا توجد مصطلحات مؤجلة حاليا';

make_page 'notes',
  make_header('موارد وإرشادات', 'notes'),
  filepath_to_html('notes/src') =~ s|<p class="seealso">[^<>]+</p>(?=<ul class="ext">)||gr;

# links and redirections {{{1

use File::Path qw[ remove_tree ];
remove_tree 'link' if -e 'link';
mkdir 'link';

use constant ROOT_FOR_LINKS => '../../';
sub make_link { my ($id, $title, $parent) = @_;
  my $url = join '', ROOT_FOR_LINKS, $parent, '#', $id;
  #
  make_page "link/$id",
    make_header("توجيه إلى \N{LEFT-TO-RIGHT EMBEDDING}$title\N{POP DIRECTIONAL FORMATTING} آليا", "link/$id", ROOT_FOR_LINKS)
      =~ s,\n</head>,\n  <meta http-equiv="Refresh" content="0; url=$url">$&,r,
    qq[<center class="redirect">ستوجه الآن إلى <a dir="ltr" href="$url">$title</a> آليا<br>(اضغط على الرابط أعلاه إن لم توجه)</center>];
}

for my $word (keys %links) {
  my $info = $terms{$links{$word}};
  make_link $word, $info->{title}, $info->{stage};
}

# ...and the links index

use constant EMPTY_STAGE_LINKS => qq[  <center class="blurred">لا توجد مصطلحات في هذه المرحلة حاليا</center>];

make_page 'link',
  make_header('روابط جميع المصطلحات', 'link'),
  do {
    my %toc;
    for my $t (keys %terms) {
      my $cat = $terms{$t}{cat};  # w, c, x, u
      push @{$toc{$cat}}, [ $t, "../$terms{$t}{stage}#$t" ]
    }
    # return
    TOC_FILTER =~ s|\Q{{stage}}\E|link/|gr .
    sprintf qq[<section><h2><a class="other" href="../%s">%s</a></h2>\n%s\n</section>%s] x 4,
      '',              'المصطلحات المتفق عليها',     toc_links(@{$toc{w}}) // EMPTY_STAGE_LINKS, "\n",
      'candidate/',    'المصطلحات المرشحة للاتفاق',  toc_links(@{$toc{c}}) // EMPTY_STAGE_LINKS, "\n",
      'experimental/', 'المصطلحات التجريبية',        toc_links(@{$toc{x}}) // EMPTY_STAGE_LINKS, "\n",
      'unstaged/',     'المصطلحات المؤجلة',          toc_links(@{$toc{u}}) // EMPTY_STAGE_LINKS, ""
  },
  'all';

# finally the atom feed

gen_atom %terms unless $debug_release;
